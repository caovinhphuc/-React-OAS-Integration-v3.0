#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
üìÑ Pagination Handler Module - X·ª≠ l√Ω ph√¢n trang ƒë·ªÉ l·∫•y h·∫øt d·ªØ li·ªáu
Handles: total records extraction, page navigation, complete data collection
"""

import time
import re
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException


class PaginationHandler:
    """
    üìÑ Class x·ª≠ l√Ω ph√¢n trang DataTables ƒë·ªÉ l·∫•y h·∫øt d·ªØ li·ªáu
    Based on: ONE_SYSTEM_STRUCTURE.md pagination analysis
    """

    def __init__(self, driver, logger):
        self.driver = driver
        self.logger = logger

    def get_total_records(self):
        """
        üìä L·∫•y t·ªïng s·ªë d√≤ng t·ª´ DataTables info

        Returns:
            int: T·ªïng s·ªë records ho·∫∑c 0 n·∫øu kh√¥ng t√¨m th·∫•y
        """
        try:
            # ƒê·ª£i info element xu·∫•t hi·ªán
            WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.ID, "orderTB_info"))
            )

            info_element = self.driver.find_element(By.ID, "orderTB_info")
            info_text = info_element.text.strip()

            self.logger.info(f"üìä DataTables info: {info_text}")

            # Parse text: "Hi·ªÉn th·ªã 1 ƒë·∫øn 2,000 trong t·ªïng s·ªë 15,847 d√≤ng"
            # Ho·∫∑c: "Showing 1 to 2,000 of 15,847 entries"
            patterns = [
                r"trong t·ªïng s·ªë ([\d,]+) d√≤ng",  # Vietnamese
                r"of ([\d,]+) entries",          # English
                r"t·ªïng c·ªông ([\d,]+)",           # Alternative Vietnamese
                r"total ([\d,]+)"                # Alternative English
            ]

            for pattern in patterns:
                match = re.search(pattern, info_text, re.IGNORECASE)
                if match:
                    total_str = match.group(1).replace(',', '')
                    total_records = int(total_str)
                    self.logger.info(f"‚úÖ Total records found: {total_records:,}")
                    return total_records

            # Fallback: try to find numbers in text
            numbers = re.findall(r'[\d,]+', info_text)
            if numbers:
                # Take the largest number as total
                largest = max([int(n.replace(',', '')) for n in numbers])
                self.logger.warning(f"‚ö†Ô∏è Using fallback total: {largest:,}")
                return largest

            self.logger.warning(f"‚ö†Ô∏è Could not parse total from: {info_text}")
            return 0

        except Exception as e:
            self.logger.error(f"‚ùå Error getting total records: {e}")
            return 0

    def get_current_page_info(self):
        """
        üìÑ L·∫•y th√¥ng tin trang hi·ªán t·∫°i

        Returns:
            dict: {current_page: int, has_next: bool, has_previous: bool}
        """
        try:
            # T√¨m current page
            current_page = 1
            try:
                current_element = self.driver.find_element(By.CSS_SELECTOR, ".paginate_button.current")
                current_page = int(current_element.text.strip())
            except:
                pass

            # Ki·ªÉm tra next button
            has_next = True
            try:
                next_button = self.driver.find_element(By.CSS_SELECTOR, ".paginate_button.next")
                if "disabled" in next_button.get_attribute("class"):
                    has_next = False
            except:
                has_next = False

            # Ki·ªÉm tra previous button
            has_previous = True
            try:
                prev_button = self.driver.find_element(By.CSS_SELECTOR, ".paginate_button.previous")
                if "disabled" in prev_button.get_attribute("class"):
                    has_previous = False
            except:
                has_previous = False

            return {
                'current_page': current_page,
                'has_next': has_next,
                'has_previous': has_previous
            }

        except Exception as e:
            self.logger.error(f"‚ùå Error getting page info: {e}")
            return {'current_page': 1, 'has_next': False, 'has_previous': False}

    def go_to_next_page(self, wait_timeout=30):
        """
        ‚û°Ô∏è Chuy·ªÉn sang trang ti·∫øp theo v·ªõi proper waiting v√† content change detection

        Args:
            wait_timeout (int): Timeout ch·ªù trang load

        Returns:
            bool: True n·∫øu th√†nh c√¥ng, False n·∫øu kh√¥ng c√≥ trang ti·∫øp
        """
        try:
            # Ki·ªÉm tra c√≥ next button kh√¥ng
            page_info = self.get_current_page_info()
            if not page_info['has_next']:
                self.logger.info("üìÑ No more pages available")
                return False

            current_page = page_info['current_page']
            self.logger.info(f"üìÑ Attempting to go from page {current_page} to next page...")

            # Capture current table content ƒë·ªÉ so s√°nh sau
            old_content = self._get_table_content_snapshot()
            self.logger.info(f"üì∏ Captured current table content: {len(old_content)} items")

            # STRATEGY 1: Scroll to pagination area first
            try:
                self.logger.info("üîÑ Strategy 1: Scroll to pagination area...")
                self.driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
                time.sleep(1)

                # Find pagination container and scroll to it
                pagination_container = self.driver.find_element(By.CSS_SELECTOR, ".dataTables_paginate")
                self.driver.execute_script("arguments[0].scrollIntoView(true);", pagination_container)
                time.sleep(1)

            except Exception as e:
                self.logger.warning(f"‚ö†Ô∏è Scroll strategy failed: {e}")

            # STRATEGY 2: Try JavaScript click first
            try:
                self.logger.info("üîÑ Strategy 2: JavaScript click...")

                js_click_script = """
                var nextButtons = document.querySelectorAll('.paginate_button.next');
                for (var i = 0; i < nextButtons.length; i++) {
                    var btn = nextButtons[i];
                    if (!btn.classList.contains('disabled') && btn.offsetWidth > 0 && btn.offsetHeight > 0) {
                        btn.click();
                        return true;
                    }
                }
                return false;
                """

                clicked = self.driver.execute_script(js_click_script)
                if clicked:
                    self.logger.info("‚úÖ JavaScript click successful")

                    # ƒê·ª£i table content thay ƒë·ªïi
                    if self._wait_for_table_content_change(old_content, timeout=15):
                        new_page_info = self.get_current_page_info()
                        if new_page_info['current_page'] > current_page:
                            self.logger.info(f"üìÑ Successfully moved to page {new_page_info['current_page']}")
                            return True

            except Exception as e:
                self.logger.warning(f"‚ö†Ô∏è JavaScript strategy failed: {e}")

            # STRATEGY 3: Try Selenium click with multiple selectors
            try:
                self.logger.info("üîÑ Strategy 3: Selenium click with multiple selectors...")

                selectors = [
                    ".paginate_button.next:not(.disabled)",
                    "a.paginate_button.next",
                    ".dataTables_paginate .next",
                    ".paginate_button[data-dt-idx]:last-child"
                ]

                for selector in selectors:
                    try:
                        next_button = self.driver.find_element(By.CSS_SELECTOR, selector)
                        if next_button.is_displayed() and next_button.is_enabled():
                            # Scroll to button
                            self.driver.execute_script("arguments[0].scrollIntoView(true);", next_button)
                            time.sleep(0.5)

                            # Try click
                            next_button.click()
                            self.logger.info(f"‚úÖ Clicked with selector: {selector}")

                            # ƒê·ª£i table content thay ƒë·ªïi
                            if self._wait_for_table_content_change(old_content, timeout=15):
                                new_page_info = self.get_current_page_info()
                                if new_page_info['current_page'] > current_page:
                                    self.logger.info(f"üìÑ Successfully moved to page {new_page_info['current_page']}")
                                    return True

                    except Exception as e:
                        self.logger.debug(f"Selector {selector} failed: {e}")
                        continue

            except Exception as e:
                self.logger.warning(f"‚ö†Ô∏è Selenium strategy failed: {e}")

            # STRATEGY 4: Direct page navigation via URL manipulation
            try:
                self.logger.info("üîÑ Strategy 4: Direct URL navigation...")

                current_url = self.driver.current_url

                # Try to increment page in URL if it exists
                if "page=" in current_url:
                    import re
                    new_url = re.sub(r'page=(\d+)', lambda m: f"page={int(m.group(1)) + 1}", current_url)
                    self.driver.get(new_url)
                    time.sleep(3)

                    new_page_info = self.get_current_page_info()
                    if new_page_info['current_page'] > current_page:
                        self.logger.info(f"üìÑ URL navigation successful to page {new_page_info['current_page']}")
                        return True

            except Exception as e:
                self.logger.warning(f"‚ö†Ô∏è URL navigation failed: {e}")

            # STRATEGY 5: DataTables API direct navigation
            try:
                self.logger.info("üîÑ Strategy 5: DataTables API navigation...")

                dt_script = """
                if (typeof $ !== 'undefined' && $('#orderTB').length > 0) {
                    var table = $('#orderTB').DataTable();
                    table.page('next').draw('page');
                    return true;
                }
                return false;
                """

                api_success = self.driver.execute_script(dt_script)
                if api_success:
                    self.logger.info("‚úÖ DataTables API navigation successful")

                    # ƒê·ª£i table content thay ƒë·ªïi
                    if self._wait_for_table_content_change(old_content, timeout=20):
                        new_page_info = self.get_current_page_info()
                        if new_page_info['current_page'] > current_page:
                            self.logger.info(f"üìÑ Successfully moved to page {new_page_info['current_page']}")
                            return True

            except Exception as e:
                self.logger.warning(f"‚ö†Ô∏è DataTables API failed: {e}")

            # All strategies failed
            self.logger.error(f"‚ùå All pagination strategies failed for page {current_page}")
            return False

        except Exception as e:
            self.logger.error(f"‚ùå Error in go_to_next_page: {e}")
            return False

    def _get_table_content_snapshot(self):
        """üì∏ Capture table content snapshot ƒë·ªÉ detect changes"""
        try:
            js_script = """
            var rows = document.querySelectorAll('#orderTB tbody tr');
            var snapshot = [];
            for (var i = 0; i < Math.min(rows.length, 3); i++) {
                var row = rows[i];
                var cells = row.querySelectorAll('td');
                if (cells.length > 0) {
                    snapshot.push(cells[0].textContent.trim() + '|' + cells[1].textContent.trim());
                }
            }
            return snapshot;
            """

            result = self.driver.execute_script(js_script)
            return result if result else []

        except Exception as e:
            self.logger.debug(f"‚ö†Ô∏è Error capturing table snapshot: {e}")
            return []

    def _wait_for_table_content_change(self, old_content, timeout=30):
        """‚è≥ ƒê·ª£i table content thay ƒë·ªïi"""
        try:
            self.logger.info(f"‚è≥ Waiting for table content to change (timeout: {timeout}s)...")

            start_time = time.time()
            check_interval = 0.5

            while time.time() - start_time < timeout:
                # ƒê·ª£i m·ªôt ch√∫t tr∆∞·ªõc khi check
                time.sleep(check_interval)

                # L·∫•y content m·ªõi
                new_content = self._get_table_content_snapshot()

                # So s√°nh v·ªõi content c≈©
                if new_content != old_content and len(new_content) > 0:
                    self.logger.info(f"‚úÖ Table content changed! New content: {len(new_content)} items")

                    # ƒê·ª£i th√™m m·ªôt ch√∫t cho table ·ªïn ƒë·ªãnh
                    time.sleep(2)
                    return True

                # TƒÉng interval ƒë·ªÉ kh√¥ng spam request
                check_interval = min(check_interval * 1.1, 2.0)

            self.logger.warning(f"‚ùå Timeout waiting for table content change ({timeout}s)")
            return False

        except Exception as e:
            self.logger.error(f"‚ùå Error waiting for table content change: {e}")
            return False

    def extract_all_pages_data(self, extract_function, max_pages=50):
        """
        üìä L·∫•y d·ªØ li·ªáu t·ª´ t·∫•t c·∫£ c√°c trang

        Args:
            extract_function: Function ƒë·ªÉ extract data t·ª´ 1 trang
            max_pages (int): Gi·ªõi h·∫°n s·ªë trang t·ªëi ƒëa ƒë·ªÉ tr√°nh infinite loop

        Returns:
            dict: {all_data: list, total_extracted: int, total_expected: int, pages_processed: int}
        """
        try:
            self.logger.info("üìä Starting complete data extraction across all pages...")

            # Get total expected records
            total_expected = self.get_total_records()
            if total_expected == 0:
                self.logger.warning("‚ö†Ô∏è No total records found, proceeding with available data")

            all_data = []
            pages_processed = 0

            while pages_processed < max_pages:
                pages_processed += 1
                page_info = self.get_current_page_info()
                current_page = page_info['current_page']

                self.logger.info(f"üìÑ Processing page {current_page} ({pages_processed}/{max_pages})...")

                # Extract data from current page
                try:
                    page_data = extract_function()
                    if page_data:
                        all_data.extend(page_data)
                        self.logger.info(f"‚úÖ Page {current_page}: extracted {len(page_data)} records")
                    else:
                        self.logger.warning(f"‚ö†Ô∏è Page {current_page}: no data extracted")

                except Exception as e:
                    self.logger.error(f"‚ùå Page {current_page}: extraction failed - {e}")

                # Check if we have next page
                if not page_info['has_next']:
                    self.logger.info(f"üìÑ Reached last page ({current_page})")
                    break

                # Go to next page
                if not self.go_to_next_page():
                    self.logger.warning("‚ö†Ô∏è Failed to go to next page, stopping")
                    break

            # Summary
            total_extracted = len(all_data)
            completion_rate = (total_extracted / total_expected * 100) if total_expected > 0 else 0

            self.logger.info(f"üìä Extraction complete:")
            self.logger.info(f"   üì¶ Total extracted: {total_extracted:,}")
            self.logger.info(f"   üéØ Total expected: {total_expected:,}")
            self.logger.info(f"   üìà Completion rate: {completion_rate:.1f}%")
            self.logger.info(f"   üìÑ Pages processed: {pages_processed}")

            return {
                'all_data': all_data,
                'total_extracted': total_extracted,
                'total_expected': total_expected,
                'pages_processed': pages_processed,
                'completion_rate': completion_rate,
                'success': total_extracted > 0
            }

        except Exception as e:
            self.logger.error(f"‚ùå Complete extraction failed: {e}")
            return {
                'all_data': [],
                'total_extracted': 0,
                'total_expected': 0,
                'pages_processed': 0,
                'completion_rate': 0,
                'success': False,
                'error': str(e)
            }

    def quick_page_count_estimate(self):
        """
        ‚ö° ∆Ø·ªõc t√≠nh nhanh s·ªë trang d·ª±a tr√™n total records

        Returns:
            dict: {estimated_pages: int, records_per_page: int}
        """
        try:
            total_records = self.get_total_records()
            if total_records == 0:
                return {'estimated_pages': 0, 'records_per_page': 0}

            # Assume 2000 records per page (max limit)
            records_per_page = 2000
            estimated_pages = (total_records + records_per_page - 1) // records_per_page

            self.logger.info(f"üìä Estimated: {estimated_pages} pages for {total_records:,} records")

            return {
                'estimated_pages': estimated_pages,
                'records_per_page': records_per_page,
                'total_records': total_records
            }

        except Exception as e:
            self.logger.error(f"‚ùå Error estimating pages: {e}")
            return {'estimated_pages': 0, 'records_per_page': 0, 'total_records': 0}


# Convenience functions
def extract_complete_data(driver, logger, extract_function, max_pages=50):
    """
    üéØ Convenience function ƒë·ªÉ extract h·∫øt d·ªØ li·ªáu t·ª´ t·∫•t c·∫£ trang

    Args:
        driver: WebDriver instance
        logger: Logger instance
        extract_function: Function ƒë·ªÉ extract data t·ª´ 1 trang
        max_pages (int): Gi·ªõi h·∫°n s·ªë trang

    Returns:
        dict: Complete extraction result
    """
    handler = PaginationHandler(driver, logger)
    return handler.extract_all_pages_data(extract_function, max_pages)


def get_total_records_count(driver, logger):
    """
    üìä Quick function ƒë·ªÉ l·∫•y t·ªïng s·ªë records

    Returns:
        int: Total records count
    """
    handler = PaginationHandler(driver, logger)
    return handler.get_total_records()


if __name__ == "__main__":
    """Test the pagination handler module"""
    print("üìÑ Pagination Handler Module")
    print("Use this module to extract complete data across all pages")
    print("Example: extract_complete_data(driver, logger, your_extract_function)")
