// src/services/notifications/telegramService.ts
import TelegramBot from 'node-telegram-bot-api';
import { Order } from '@/services/googleSheets/ordersService';

export interface TelegramMessage {
  chatId: string;
  message: string;
  options?: TelegramBot.SendMessageOptions;
}

export interface TelegramNotificationTemplate {
  id: string;
  name: string;
  template: string;
  variables: string[];
}

export class TelegramNotificationService {
  private bot: TelegramBot;
  private webhookUrl: string;
  private templates: Map<string, TelegramNotificationTemplate> = new Map();

  constructor(token: string, webhookUrl?: string) {
    this.bot = new TelegramBot(token, { polling: !webhookUrl });
    this.webhookUrl = webhookUrl || '';
    this.initializeTemplates();
    this.setupCommands();

    if (webhookUrl) {
      this.setupWebhook();
    }
  }

  private async setupWebhook(): Promise<void> {
    try {
      await this.bot.setWebHook(`${this.webhookUrl}/webhook/telegram`);
      console.log('‚úÖ Telegram webhook setup successful');
    } catch (error) {
      console.error('‚ùå Telegram webhook setup failed:', error);
    }
  }

  private initializeTemplates(): void {
    const templates: TelegramNotificationTemplate[] = [
      {
        id: 'order_created',
        name: 'ƒê∆°n h√†ng ƒë∆∞·ª£c t·∫°o',
        template: `
üÜï *ƒê∆°n h√†ng m·ªõi ƒë∆∞·ª£c t·∫°o*

üì¶ M√£ ƒë∆°n: \`{{orderId}}\`
üë§ Kh√°ch h√†ng: {{customerName}}
üì± SƒêT: {{customerPhone}}
üìç T·ª´: {{pickupAddress}}
üìç ƒê·∫øn: {{deliveryAddress}}
üí∞ ∆Ø·ªõc t√≠nh: {{estimatedCost}} VND
üìÖ Ng√†y t·∫°o: {{createdAt}}

[Xem chi ti·∫øt]({{detailUrl}})
        `,
        variables: [
          'orderId',
          'customerName',
          'customerPhone',
          'pickupAddress',
          'deliveryAddress',
          'estimatedCost',
          'createdAt',
          'detailUrl',
        ],
      },
      {
        id: 'order_confirmed',
        name: 'ƒê∆°n h√†ng ƒë∆∞·ª£c x√°c nh·∫≠n',
        template: `
‚úÖ *ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c x√°c nh·∫≠n*

üì¶ M√£ ƒë∆°n: \`{{orderId}}\`
üöõ Nh√† v·∫≠n chuy·ªÉn: {{carrierName}}
üìÖ Th·ªùi gian l·∫•y h√†ng: {{scheduledPickup}}
üí∞ Chi ph√≠: {{actualCost}} VND

[Theo d√µi ƒë∆°n h√†ng]({{trackingUrl}})
        `,
        variables: [
          'orderId',
          'carrierName',
          'scheduledPickup',
          'actualCost',
          'trackingUrl',
        ],
      },
      {
        id: 'order_pickup',
        name: 'ƒê√£ l·∫•y h√†ng',
        template: `
üì§ *ƒê√£ l·∫•y h√†ng th√†nh c√¥ng*

üì¶ M√£ ƒë∆°n: \`{{orderId}}\`
üìÖ Th·ªùi gian l·∫•y: {{actualPickup}}
üöõ ƒêang v·∫≠n chuy·ªÉn ƒë·∫øn: {{deliveryAddress}}
‚è±Ô∏è D·ª± ki·∫øn giao: {{estimatedDelivery}}

[Theo d√µi real-time]({{trackingUrl}})
        `,
        variables: [
          'orderId',
          'actualPickup',
          'deliveryAddress',
          'estimatedDelivery',
          'trackingUrl',
        ],
      },
      {
        id: 'order_delivered',
        name: 'ƒê√£ giao h√†ng',
        template: `
üéâ *Giao h√†ng th√†nh c√¥ng*

üì¶ M√£ ƒë∆°n: \`{{orderId}}\`
üìÖ Th·ªùi gian giao: {{actualDelivery}}
üë§ Ng∆∞·ªùi nh·∫≠n: {{receiverName}}
üìã Ghi ch√∫: {{deliveryNotes}}

C·∫£m ∆°n b·∫°n ƒë√£ s·ª≠ d·ª•ng d·ªãch v·ª• MIA! üôè
        `,
        variables: [
          'orderId',
          'actualDelivery',
          'receiverName',
          'deliveryNotes',
        ],
      },
      {
        id: 'daily_summary',
        name: 'T·ªïng k·∫øt ng√†y',
        template: `
üìä *B√°o c√°o cu·ªëi ng√†y* - {{date}}

üì¶ T·ªïng ƒë∆°n h√†ng: {{totalOrders}}
‚úÖ ƒê√£ ho√†n th√†nh: {{completedOrders}}
üöõ ƒêang v·∫≠n chuy·ªÉn: {{inTransitOrders}}
‚è≥ Ch·ªù x·ª≠ l√Ω: {{pendingOrders}}
üí∞ Doanh thu: {{totalRevenue}} VND

üìà [Xem b√°o c√°o chi ti·∫øt]({{reportUrl}})
        `,
        variables: [
          'date',
          'totalOrders',
          'completedOrders',
          'inTransitOrders',
          'pendingOrders',
          'totalRevenue',
          'reportUrl',
        ],
      },
    ];

    templates.forEach((template) => {
      this.templates.set(template.id, template);
    });
  }

  private setupCommands(): void {
    // Help command
    this.bot.onText(/\/help/, (msg) => {
      const chatId = msg.chat.id;
      const helpMessage = `
ü§ñ *MIA Logistics Bot Commands*

üìä /status - Tr·∫°ng th√°i h·ªá th·ªëng
üì¶ /orders - Danh s√°ch ƒë∆°n h√†ng
üîç /track [m√£ ƒë∆°n] - Theo d√µi ƒë∆°n h√†ng
üìà /report - B√°o c√°o h√¥m nay
‚öôÔ∏è /settings - C√†i ƒë·∫∑t th√¥ng b√°o
‚ùì /help - Hi·ªÉn th·ªã tr·ª£ gi√∫p

Li√™n h·ªá h·ªó tr·ª£: @mia_support
      `;

      this.bot.sendMessage(chatId, helpMessage, { parse_mode: 'Markdown' });
    });

    // Status command
    this.bot.onText(/\/status/, async (msg) => {
      const chatId = msg.chat.id;
      try {
        const status = await this.getSystemStatus();
        this.bot.sendMessage(chatId, status, { parse_mode: 'Markdown' });
      } catch (error) {
        this.bot.sendMessage(chatId, '‚ùå L·ªói khi l·∫•y tr·∫°ng th√°i h·ªá th·ªëng');
      }
    });

    // Track order command
    this.bot.onText(/\/track (.+)/, async (msg, match) => {
      const chatId = msg.chat.id;
      const orderId = match?.[1];

      if (!orderId) {
        this.bot.sendMessage(
          chatId,
          '‚ùå Vui l√≤ng nh·∫≠p m√£ ƒë∆°n h√†ng. V√≠ d·ª•: /track ORD-123'
        );
        return;
      }

      try {
        const orderInfo = await this.getOrderInfo(orderId);
        this.bot.sendMessage(chatId, orderInfo, { parse_mode: 'Markdown' });
      } catch (error) {
        this.bot.sendMessage(chatId, `‚ùå Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng: ${orderId}`);
      }
    });

    // Settings command
    this.bot.onText(/\/settings/, (msg) => {
      const chatId = msg.chat.id;
      const keyboard = {
        inline_keyboard: [
          [
            { text: 'üîî B·∫≠t th√¥ng b√°o', callback_data: 'enable_notifications' },
            {
              text: 'üîï T·∫Øt th√¥ng b√°o',
              callback_data: 'disable_notifications',
            },
          ],
          [
            { text: 'üìä B√°o c√°o h√†ng ng√†y', callback_data: 'daily_reports' },
            { text: 'üìà B√°o c√°o h√†ng tu·∫ßn', callback_data: 'weekly_reports' },
          ],
          [
            {
              text: '‚öôÔ∏è T√πy ch·ªânh n√¢ng cao',
              callback_data: 'advanced_settings',
            },
          ],
        ],
      };

      this.bot.sendMessage(
        chatId,
        '‚öôÔ∏è *C√†i ƒë·∫∑t th√¥ng b√°o*\n\nCh·ªçn t√πy ch·ªçn b√™n d∆∞·ªõi:',
        {
          parse_mode: 'Markdown',
          reply_markup: keyboard,
        }
      );
    });

    // Handle callback queries
    this.bot.on('callback_query', async (callbackQuery) => {
      const action = callbackQuery.data;
      const chatId = callbackQuery.message?.chat.id;

      if (!chatId) return;

      switch (action) {
        case 'enable_notifications':
          await this.updateUserSettings(chatId.toString(), {
            notifications: true,
          });
          this.bot.answerCallbackQuery(callbackQuery.id, {
            text: '‚úÖ ƒê√£ b·∫≠t th√¥ng b√°o',
          });
          break;
        case 'disable_notifications':
          await this.updateUserSettings(chatId.toString(), {
            notifications: false,
          });
          this.bot.answerCallbackQuery(callbackQuery.id, {
            text: 'üîï ƒê√£ t·∫Øt th√¥ng b√°o',
          });
          break;
        default:
          this.bot.answerCallbackQuery(callbackQuery.id, {
            text: 'T√≠nh nƒÉng ƒëang ph√°t tri·ªÉn',
          });
      }
    });
  }

  public async sendOrderNotification(
    chatId: string,
    templateId: string,
    order: Order,
    additionalData: Record<string, any> = {}
  ): Promise<void> {
    const template = this.templates.get(templateId);
    if (!template) {
      throw new Error(`Template not found: ${templateId}`);
    }

    const variables = {
      orderId: order.orderId,
      customerName: order.customerName,
      customerPhone: order.customerPhone,
      pickupAddress: order.pickupAddress,
      deliveryAddress: order.deliveryAddress,
      estimatedCost: order.estimatedCost?.toLocaleString('vi-VN'),
      actualCost: order.actualCost?.toLocaleString('vi-VN'),
      createdAt: new Date(order.createdAt).toLocaleDateString('vi-VN'),
      carrierName: order.carrierName || 'Ch∆∞a ch·ªçn',
      status: this.getStatusText(order.status),
      ...additionalData,
    };

    const message = this.interpolateTemplate(template.template, variables);

    const options: TelegramBot.SendMessageOptions = {
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [
          [
            {
              text: 'üìç Theo d√µi',
              url: `${process.env.REACT_APP_BASE_URL}/tracking/${order.orderId}`,
            },
            { text: 'üìû Li√™n h·ªá', callback_data: `contact_${order.orderId}` },
          ],
        ],
      },
    };

    try {
      await this.bot.sendMessage(chatId, message, options);
    } catch (error) {
      console.error('Error sending Telegram notification:', error);
      throw error;
    }
  }

  public async sendBulkNotification(
    chatIds: string[],
    message: string,
    options?: TelegramBot.SendMessageOptions
  ): Promise<void> {
    const promises = chatIds.map((chatId) =>
      this.bot.sendMessage(chatId, message, options).catch((error) => {
        console.error(`Failed to send message to ${chatId}:`, error);
        return null;
      })
    );

    await Promise.allSettled(promises);
  }

  public async sendDocument(
    chatId: string,
    document: Buffer,
    filename: string,
    caption?: string
  ): Promise<void> {
    try {
      await this.bot.sendDocument(chatId, document, {
        filename,
        caption,
      });
    } catch (error) {
      console.error('Error sending document:', error);
      throw error;
    }
  }

  private interpolateTemplate(
    template: string,
    variables: Record<string, any>
  ): string {
    return template.replace(/\{\{(\w+)\}\}/g, (match, key) => {
      return variables[key] || match;
    });
  }

  private getStatusText(status: string): string {
    const statusMap: Record<string, string> = {
      PENDING: '‚è≥ Ch·ªù x·ª≠ l√Ω',
      CONFIRMED: '‚úÖ ƒê√£ x√°c nh·∫≠n',
      PICKUP: 'üì§ ƒêang l·∫•y h√†ng',
      IN_TRANSIT: 'üöõ ƒêang v·∫≠n chuy·ªÉn',
      DELIVERED: '‚úÖ ƒê√£ giao',
      CANCELLED: '‚ùå ƒê√£ h·ªßy',
    };
    return statusMap[status] || status;
  }

  private async getSystemStatus(): Promise<string> {
    // Mock system status - in real app, get from monitoring service
    return `
üîß *Tr·∫°ng th√°i h·ªá th·ªëng MIA*

‚úÖ API Server: Ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng
‚úÖ Database: K·∫øt n·ªëi ·ªïn ƒë·ªãnh
‚úÖ Google Maps: Ho·∫°t ƒë·ªông
‚úÖ Email Service: Ho·∫°t ƒë·ªông
üîÑ Uptime: 99.9%

üìä Th·ªëng k√™ 24h qua:
- ƒê∆°n h√†ng x·ª≠ l√Ω: 156
- Th√¥ng b√°o g·ª≠i: 423
- Th·ªùi gian ph·∫£n h·ªìi: 0.8s

C·∫≠p nh·∫≠t l√∫c: ${new Date().toLocaleString('vi-VN')}
    `;
  }

  private async getOrderInfo(orderId: string): Promise<string> {
    // Mock order info - integrate with actual order service
    return `
üì¶ *Th√¥ng tin ƒë∆°n h√†ng: ${orderId}*

üë§ Kh√°ch h√†ng: Nguy·ªÖn VƒÉn A
üì± SƒêT: 0901234567
üìç T·ª´: H√† N·ªôi
üìç ƒê·∫øn: TP.HCM
üöõ Nh√† VC: Giao H√†ng Nhanh
üí∞ Chi ph√≠: 250,000 VND

üìä Tr·∫°ng th√°i: üöõ ƒêang v·∫≠n chuy·ªÉn
üìÖ D·ª± ki·∫øn giao: 19/08/2025 10:00

üîÑ L·ªãch s·ª≠:
- 18/08 08:00 - ƒê√£ l·∫•y h√†ng
- 18/08 14:30 - ƒêang v·∫≠n chuy·ªÉn
- 19/08 10:00 - D·ª± ki·∫øn giao h√†ng
    `;
  }

  private async updateUserSettings(
    chatId: string,
    settings: Record<string, any>
  ): Promise<void> {
    // Mock settings update - integrate with user service
    console.log(`Updating settings for ${chatId}:`, settings);
  }

  public processWebhook(body: any): void {
    this.bot.processUpdate(body);
  }

  public async close(): Promise<void> {
    await this.bot.close();
  }
}
